---
title: "Intro to the tidyverse"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(fig.path = 'figures/')
```

The tidyverse is not just one package, but a collection of several packages that
are designed to work well together for data analysis tasks. Let's load the
tidyverse and read in the metadata again.

```{r loadMetadata}
library(tidyverse)
metadata <- read_csv("0_data/metadata.csv")
```

Take a look at the dataset with `View()`:

```{r, eval=FALSE}
View(metadata)
```

# Intro dplyr

## summarize

Let's start with a useful function called `summarize()` that will let us summarize variables in our data frame. We can use it to find the mean, median, or other statistics about the dataset. Let's find the average age in days below:

```{r}
summarize(metadata, mean_age_days = mean(age_dys))
```

The first argument to the summarize function is our data frame, and the second
argument is a new variable that we want summarize to create from the `age_dys` column.

### pipes

Instead of including the data as an argument, we can use the *pipe operator* `%>%` to pass the data value into the `summarize` function. 

```{r Avgage_dysWithPipe}
metadata %>% summarize(mean_age_days = mean(age_dys))
```
 
This line of code will do the exact same thing as our first summary command, but the piping function tells R to use the `metadata` data frame as the first argument in the next function.

This lets us "chain" together multiple functions, which will be helpful later. Note that the pipe (`%>%`) is a bit different from using the ggplot plus (`+`). Pipes take the output from the left side and use it as input to the right side. Plusses layer on additional information (right side) to a preexisting plot (left side). 
 
We can also add an <kdb>Enter</kdb> to make it look nicer:  

```{r Avgage_dysWithPipe2}
metadata %>%
  summarize(mean_age_days = mean(age_dys))
```

Using the *pipe operator* `%>%` and enter command makes our code more readable. The  *pipe operator* `%>%` also helps to avoid using nested function and minimizes the need for new variables.

Since we use the pipe operator so often, there is a keyboard shortcut for it in RStudio. You can press <kdb>Ctrl</kdb>+<kdb>Shift</kdb>+<kdb>M<kdb> on Windows or <kdb>Cmd<kdb>+<kdb>Shift<kdb>+<kdb>M<kdb> on a Mac.

> ## Pro tip: Saving a new dataframe
> Notice that when we run the following code, we are not actually saving a new variable: 
> ```{r Avgage_dysWithPipe3, eval = FALSE}
> metadata %>%
>   summarize(mean_age_days=mean(age_dys))
> ```
> This simply outputs what we have created, but does not change actually change `metadata` or save a new dataframe. To save a new dataframe, we could run: 
> ```{r saveNewDF, eval = FALSE}
> metadata_summarized <- metadata %>%
>   summarize(mean_age_days=mean(age_dys))
> ```
> Or if we want to change `metadata` itself: 
> ```{r overwriteDF, eval = FALSE}
> metadata <- metadata %>%
>   summarize(mean_age_days=mean(age_dys))
> ```
> IMPORTANT: This would overwrite the existing `metadata` object. 
> 
> For now, we will not be saving dataframes, since we are just experimenting with `dyplr` functions, but it will be useful later on in this lesson. 
> 
{: .callout}

### group_by

```{r}
metadata %>% 
  group_by(sex) %>% 
  summarize(mean_age_days = mean(age_dys))
```


## select

select: remove unneeded variable (ptID_old), keep only needed variables

```{r}
metadata %>% 
  select(ptID, age_dys)
```

```{r}
metadata %>% 
  select(-ptID_old)
```

## filter

filter: media-only samples

```{r}
metadata %>% 
  filter(condition == 'Media')
```

> ## Quotes vs No Quotes
> Notice that when we added the label value we did so by placing the values
> inside quotes. This is because we are not using a value from inside our data
> object - we are providing the name directly. When you need to include actual
> text values in R, they will be placed inside quotes to tell them apart from
> other object or variable names.
> 
> The general rule is that if you want to use values from the columns of your
> data object, then you supply the name of the column without quotes, but if you
> want to specify a value that does not come from your data, then use quotes.


```{r}
metadata %>% 
  filter(condition != 'Mtb')
```
```{r}
metadata %>% 
  filter(condition == 'Media', total_seq > 7000000)
```


## mutate

Adding new variables from existing ones

```{r}
metadata %>% 
  mutate(age_yrs = age_dys / 365.25)
```

# Intro ggplot

We will be using the `ggplot2` package today to make our plots. This is a very
powerful package that creates professional looking plots and is one of the
reasons people like using R so much. All plots made using the `ggplot2` package
start by calling the `ggplot()` function. 

```{r}
metadata %>% ggplot()
```


When we run this code, the **Plots** tab will pop to the front in the lower
right corner of the RStudio screen. Right now, we just see a big grey rectangle.

What we've done is created a ggplot object and told it we will be using the data
from the `metadata` object that we've loaded into R. We've done this by
calling the `ggplot()` function with `metadata` as the `data` argument.

So we've made a plot object, now we need to start telling it what we actually
want to draw in this plot. The elements of a plot have a bunch of properties
like an x and y position, a size, a color, etc. These properties are called
**aesthetics**. When creating a data visualization, we  map a variable in our
dataset to an aesthetic in our plot. In ggplot, we can do this by creating an
"aesthetic mapping", which we do with the `aes()` function.

To create our plot, we need to map variables from our `metadata` object to
ggplot aesthetics using the `aes()` function. Since we have already told
`ggplot` that we are using the data in the `metadata` object, we can
access the columns of `metadata` using the object's column names.
(Remember, R is case-sensitive, so we have to be careful to match the column
names exactly!)

We are interested in the total sequences per sample, so let's start by telling our plot object that we want to assign this variable to the x axis of our plot. We do this by adding (`+`) information to
our plot object. Add this new line to your code and run both lines by
highlighting them and pressing <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your
keyboard:

```{r, ggplotX}
metadata %>% 
ggplot() +
  aes(y = total_seq)
```

Note that we've added this new function call to a second line just to make it
easier to read. To do this we make sure that the `+` is at the end of the first
line otherwise R will assume your command ends when it starts the next row. The
`+` sign indicates not only that we are adding information, but to continue on
to the next line of code.

Observe that our **Plot** window is no longer a grey square. We now see that
we've mapped the `total_seq` column to the x axis of our plot. Note that that
column name isn't very pretty as an x-axis label, so let's add the `labs()`
function to make a nicer label for the x axis

```{r}
metadata %>% 
ggplot() +
  aes(y = total_seq) +
  labs(y = "Total sequences")
```

OK. That looks better. 

```{r}
metadata %>% 
ggplot() +
  aes(x = age_dys, y = total_seq) +
  labs(x = "Age (days)", y = "Total sequences")
```

Excellent. We've now told our plot object where the x and y values are coming
from and what they stand for. But we haven't told our object how we want it to
draw the data. There are many different plot types (bar charts, scatter plots,
histograms, etc). We tell our plot object what to draw by adding a "geometry"
("geom" for short) to our object. We will talk about many different geometries
today, but for our first plot, let's draw our data using the "points" geometry
for each value in the data set. To do this, we add `geom_point()` to our plot
object:

```{r}
metadata %>% 
ggplot() +
  aes(x = age_dys, y = total_seq) +
  labs(x = "Age (days)", y = "Total sequences") +
  geom_point()
```

Now we're really getting somewhere. It finally looks like a proper plot! 
One thing we could do is use a different color for the sample conditions. To map the
condition of each point to a color, we will again use the `aes()` function:

```{r}
metadata %>% 
ggplot() +
  aes(x = age_dys, y = total_seq, color = condition) +
  labs(x = "Age (days)", y = "Total sequences") +
  geom_point()
```

So far, we've been using `geom_point()` to plot two continuous (numeric) variables.
What if we want to plot a discrete variable and a numeric variable?

Using the `metadata` data, use ggplot to create a box plot with continent on the x axis and life expectancy on the y axis. 

```{r}
metadata %>% 
 ggplot() +
  aes(x = condition, y = total_seq) +
  geom_boxplot()
```

This type of visualization makes it easy to compare the range and spread of values across groups. The "middle" 50% of the data is located inside the box and outliers that are far away from the central mass of the data are drawn as points.

Another way to plot a discrete and a continuous variable is with a bar plot.

```{r}
metadata %>% 
  ggplot() +
  aes(x = libID, y = total_seq) +
  geom_col()
```
```{r}
metadata %>% 
  ggplot() +
  aes(x = libID, y = total_seq) +
  geom_col() +
  coord_flip()
```

Let's add color!

```{r}
metadata %>% 
  ggplot() +
  aes(x = libID, y = total_seq, fill = condition) +
  geom_col() +
  coord_flip()
```
```{r}
metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col() +
  coord_flip()
```
```{r}
metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col(position = position_dodge()) +
  coord_flip()
```
```{r}
metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col(position = position_dodge())
```
We now have our first data cleaning plot, the total number of sequences per library.

## Saving plots

Let's make it pretty and then save the plot!

Add labels

```{r}
metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col(position = position_dodge()) + 
  labs(x = 'patient ID', y = 'Total sequences')
```

change theme

```{r}
metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col(position = position_dodge()) + 
  labs(x = 'patient ID', y = 'Total sequences') +
  theme_bw()
```

save to variable

```{r}
seq_per_lib_plot <- metadata %>% 
  ggplot() +
  aes(x = ptID, y = total_seq, fill = condition) +
  geom_col(position = position_dodge()) + 
  labs(x = 'patient ID', y = 'Total sequences') +
  theme_bw()
```

Take a look at it by pasting the variable name into the console: `seq_per_lib_plot`

```{r, eval = FALSE}
ggsave("sequences_per_library.png", plot = seq_per_lib_plot)
```

# Intro tidyr

## pivot_

Data comes in many shapes and sizes, and one way we classify data is either "wide" or "long." Data that is "long" has one row per observation. The metadata is in a long format. <!--TODO: REVISE-->We have one row for each country for each year and each different measurement for that country is in a different column. We might describe this data as "tidy" because it makes it easy to work with `ggplot2` and `dplyr` functions (this is where the "tidy" in "tidyverse" comes from). As tidy as it may be, sometimes we may want our data in a "wide" format. Typically in "wide" format each row represents a group of observations and each value is placed in a different column rather than a different row. For example maybe we want only one row per country and want to spread the life expectancy values into different columns (one for each year).

The `tidyr` package contains the functions `pivot_wider` and `pivot_longer` that make it easy to switch between the two formats. The `tidyr` package is included in the `tidyverse` package so we don't need to do anything to load it.

### pivot_wider

For each patient, we have two samples: `Media` and `Mtb`. 
In the metadata, the only difference in these two conditions is the `libID` column (which is redundant with the `ptID` and `condition`) and the `total_seq` column.
We can take the condition column and create two new columns, one with the total seqs in the media sample and one with the total seqs in the mtb sample. 
This is called "pivoting" the data frame "wider" because we rearrange it by creating an additional column and making it have fewer rows.
Let's try it!

```{r}
metadata %>% 
  select(-libID) %>% 
  pivot_wider(names_from = condition, values_from = total_seq)
```
Notice here that we tell `pivot_wider()` which columns to pull the names we wish our new columns to be named from the year variable, and the values to populate those columns from the lifeExp variable. (Again, neither of which have to be in quotes in the code when there are no special characters or spaces - certainly an incentive not to use special characters or spaces!) We see that the resulting table has new columns by year, and the values populate it with our remaining variables dictating the rows.

Maybe we should assign those columns more informative names:

```{r}
metadata %>% 
  select(-libID) %>% 
  pivot_wider(names_from = condition, values_from = total_seq,
              names_prefix = "total_seq_")
```

And now let's save the new wider metadata to a new variable:

```{r}
metadata_wide <- metadata %>% 
  select(-libID) %>% 
  pivot_wider(names_from = condition, values_from = total_seq)
```

Notice that the number of rows and columns has changed:
```{r}
nrow(metadata)
ncol(metadata)
nrow(metadata_wide)
ncol(metadata_wide)
```

### pivot_longer

Everything we did with `pivot_wider`, we can reverse with `pivot_longer`.
Maybe you receive a data frame in a wide format, but you need it in a long format.
Here's how we can get back to a long data frame:

```{r}
metadata_wide %>% 
  pivot_longer(c(Media, Mtb), 
               names_to = 'condition', values_to = 'total_seq')
```

## sequence data

So far, we've been working with just the metadata. But this workshop is about analyzing  RNAseq data, so let's start working with actual sequencing data.

```{r}
raw_counts <- read_csv('0_data/raw_counts.csv')
```

Take a look at the counts data with:
`View(raw_counts)`

Notice how each column is a `libID` and each row is a `hgnc_symbol`. 
The values are the raw sequence counts for the genes in each library.
Soon, we're going to want to combine the sequence data with our metadata.
But first, we need to change this from a wide to a long format.

```{r}
raw_counts %>% 
  pivot_longer(-hgnc_symbol, names_to = 'libID', values_to = 'raw_count')
```

Let's save this to a new data frame so we can re-use it later.

```{r}
raw_counts_long <- raw_counts %>% 
  pivot_longer(-hgnc_symbol, names_to = 'libID', values_to = 'raw_count')
```


## join_

Now let's combine our raw sequence counts with our metadata.
To combine two data frames, we will use a `join` function.

`?join`

We have a few options here:

> The mutating joins add columns from y to x, matching rows based on the keys:
>  - inner_join(): includes all rows in x and y.
>  - left_join(): includes all rows in x.
>  - right_join(): includes all rows in y.
>  - full_join(): includes all rows in x or y.

```{r}
inner_join(metadata, raw_counts_long, by = 'libID')
```

```{r}
full_data <- inner_join(metadata, raw_counts_long, by = 'libID')
```

# More complex pipelines

TODO showcase pivot & join prior to plotting